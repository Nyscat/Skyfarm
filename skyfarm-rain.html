<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SkyFarm — Rainfall</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Shared header styles -->
  <link rel="stylesheet" href="skyfarm-shared.css">

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js"></script>

  <!-- XLSX for Excel parsing in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f6fbf8;
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#e5e7eb;
      --brand:#0B7A6E;
      --accent:#047857;
      --danger:#b91c1c;
      --focus:#2563eb;
    }

    *{box-sizing:border-box;}
    body{
      margin:0;
      padding:0;
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text",system-ui,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#e0f2fe 0,#f6fbf8 40%,#f6fbf8 100%);
      color:var(--ink);
      -webkit-font-smoothing:antialiased;
    }
    a{text-decoration:none;color:inherit;}
    button{cursor:pointer;}
    .muted{color:var(--muted);}
    .small{font-size:.8rem;}
    .hidden{display:none;}

    /* Layout */
    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:12px 12px 40px;
    }
    h1{margin:12px 0;font-size:1.45rem;}

    .card{
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:12px;
      margin:10px 0;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
    }
    label{
      font-size:.82rem;
      color:#475569;
      display:block;
      margin-bottom:3px;
    }
    select,input,button{
      font-family:inherit;
      font-size:.9rem;
      border-radius:10px;
      border:1px solid #cbd5e1;
      padding:6px 9px;
      background:#fff;
    }
    select:focus,input:focus,button:focus{
      outline:none;
      border-color:var(--focus);
      box-shadow:0 0 0 1px rgba(37,99,235,.2);
    }

    .btn{
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:.85rem;
      padding:5px 10px;
    }
    .btn.primary{
      background:var(--brand);
      border-color:var(--brand);
      color:#fff;
    }
    .btn.danger{
      background:var(--danger);
      border-color:var(--danger);
      color:#fff;
    }

    #status{font-size:.8rem;}
    .status-warn{color:var(--danger);}

    /* Table */
    table{
      width:100%;
      border-collapse:collapse;
      margin-top:4px;
      font-size:.76rem;
    }
    th,td{
      border:1px solid #e5e7eb;
      padding:4px 5px;
      text-align:right;
    }
    th{
      background:#f9fafb;
      font-weight:600;
      color:#4b5563;
    }
    td:first-child,th:first-child{
      text-align:left;
      position:sticky;
      left:0;
      background:#f9fafb;
      z-index:1;
    }
    tr:nth-child(even) td:first-child{background:#f3f4f6;}

    td.rain-cell-editable{
      cursor:pointer;
      background:#f8fafc;
    }

    .total-row td{
      font-weight:600;
      background:#eff6ff;
    }
    .cum-row td{
      background:#ecfdf3;
    }

    /* Summary panel */
    .summary{
      margin-top:12px;
      border-radius:12px;
      border:1px dashed #cbd5e1;
      padding:10px 12px;
      background:#f9fafb;
    }
    .summary-grid{
      margin-top:8px;
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:8px;
    }
    .summary-item{
      border-radius:10px;
      background:#fff;
      border:1px solid #e5e7eb;
      padding:7px 9px;
      font-size:.78rem;
    }
    .summary-good{
      border-color:#16a34a;
      background:#f0fdf4;
    }
    .summary-bad{
      border-color:#f97316;
      background:#fff7ed;
    }
    .summary-actions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
      justify-content:flex-end;
    }

    /* Auth overlay */
    #authOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(15,23,42,.08);
      z-index:2000;
    }
    #authCard{
      width:min(520px,92vw);
      background:#fff;
      border-radius:16px;
      border:1px solid var(--line);
      padding:18px 16px 14px;
      box-shadow:0 18px 45px rgba(15,23,42,.22);
    }
    #authCard h2{margin:0 0 6px;font-size:1.1rem;}

    @media (max-width:640px){
      .wrap{padding-inline:9px;}
      table{font-size:.7rem;}
    }
  </style>
</head>

<body>
  <!-- Shared header mount point -->
  <div id="sf-header-root"></div>

  <div class="wrap">
    <h1>Rainfall</h1>

    <!-- Gauge / year selector -->
    <div class="card">
      <div class="row">
        <div>
          <label>Gauge</label>
          <select id="gaugeSel">
            <option value="">Loading gauges…</option>
          </select>
        </div>
        <div>
          <label>Year</label>
          <select id="yearSel"></select>
        </div>
        <button id="reloadBtn" class="btn" type="button">Reload</button>
        <button id="printBtn" class="btn primary" type="button">Print / PDF</button>
        <span style="flex:1;"></span>
        <span id="status" class="muted small">Loading…</span>
      </div>
      <div id="gaugeInfo" class="muted small" style="margin-top:4px;"></div>
    </div>

    <!-- Hidden historic import card, only if ?import=1 and signed in -->
    <div id="importCard" class="card" style="display:none;">
      <h2 style="margin-top:0;font-size:1rem;">Historic rainfall import</h2>
      <p class="muted small">
        Admin only. Select <strong>Consentes House - Rainfall.xlsx</strong>. This importer expects one sheet per year,
        with day numbers down column A and months across columns B–M.
      </p>
      <div class="row">
        <div>
          <label>Workbook</label>
          <input id="importFile" type="file" accept=".xlsx,.xls" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="runImportBtn" class="btn primary" type="button">Import to Firestore</button>
        </div>
        <span id="importStatus" class="muted small"></span>
      </div>
      <p class="muted small" style="margin:8px 0 0;">
        Tip: Import is idempotent. It writes docs as <code>YYYY-MM-DD</code>. Existing docs get merged.
      </p>
    </div>

    <!-- Main table -->
    <div class="card">
      <div style="overflow-x:auto;">
        <table>
          <thead id="rainHead"></thead>
          <tbody id="rainBody">
            <tr><td colspan="13">Loading…</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Insights -->
    <div id="insights" class="summary">
      <div class="row" style="justify-content:space-between;gap:10px;">
        <div class="muted small">
          Quick insights for the selected gauge.
        </div>
        <div class="summary-actions">
          <button id="refreshHistoryBtn" class="btn" type="button" title="Reads all rainfall docs for this gauge and caches results in this browser.">
            Refresh history stats
          </button>
        </div>
      </div>
      <div id="insightsContent" class="summary-grid small">
        <div>Loading insights…</div>
      </div>
    </div>

    <!-- Summary / climatology -->
    <div id="summary" class="summary">
      <div class="muted small">
        Monthly and long-term rainfall for the selected gauge and year.
      </div>
      <div id="summaryContent" class="summary-grid small">
        <div>Loading climatology…</div>
      </div>
    </div>
  </div>

  <!-- Auth overlay -->
  <div id="authOverlay">
    <div id="authCard">
      <h2>Sign in to SkyFarm</h2>
      <p class="muted small" style="margin-bottom:8px;">
        Email &amp; password only. Editing rain and importing history require sign-in.
      </p>
      <div class="row" style="margin-bottom:6px;">
        <div style="flex:1;min-width:220px;">
          <label>Email</label>
          <input id="siEmail" type="email" autocomplete="username" placeholder="you@example.com" />
        </div>
        <div style="flex:1;min-width:180px;">
          <label>Password</label>
          <input id="siPass" type="password" autocomplete="current-password" placeholder="••••••••" />
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;">
        <button id="signInBtn" class="btn primary" type="button">Sign in</button>
        <button id="closeOverlayBtn" class="btn" type="button">Close</button>
        <span id="authMsg" class="muted small" style="margin-left:8px;"></span>
      </div>
    </div>
  </div>

  <!-- Shared header script -->
  <script src="skyfarm-header.js"></script>

  <script>
    // ---------- Firebase init ----------
    const firebaseConfig = {
      apiKey: "AIzaSyBO9_0v1HdvVDuK3EFvaBGvQJIGvBwmW70",
      authDomain: "consentes-pastoral.firebaseapp.com",
      projectId: "consentes-pastoral",
      appId: "1:494858780013:web:d87497b370c82eeab06e64"
    };
    firebase.initializeApp(firebaseConfig);
    const db   = firebase.firestore();
    const auth = firebase.auth();

    // Mount shared header AFTER firebase exists
    try { window.SkyFarmHeader && SkyFarmHeader.mount(); } catch(e){ console.warn(e); }

    const $ = s => document.querySelector(s);

    const statusEl        = $('#status');
    const rainHead        = $('#rainHead');
    const rainBody        = $('#rainBody');
    const summaryContent  = $('#summaryContent');
    const gaugeInfo       = $('#gaugeInfo');
    const insightsContent = $('#insightsContent');
    const refreshHistoryBtn = $('#refreshHistoryBtn');

    const authOverlay     = $('#authOverlay');
    const signInBtn       = $('#signInBtn');
    const closeOverlayBtn = $('#closeOverlayBtn');

    const gaugeSel  = $('#gaugeSel');
    const yearSel   = $('#yearSel');
    const reloadBtn = $('#reloadBtn');
    const printBtn  = $('#printBtn');

    const importCard   = $('#importCard');
    const importFile   = $('#importFile');
    const importBtn    = $('#runImportBtn');
    const importStatus = $('#importStatus');
    const showImport   = new URLSearchParams(location.search).get('import') === '1';

    const ACTIVE_GAUGE_KEY = 'sf.activeGaugeId';
    const ACTIVE_YEAR_KEY  = 'sf.activeRainYear';

    // Threshold for a "rain day"
    const RAIN_DAY_THRESHOLD_MM = 0.1;

    // Brisbane timezone for "today"
    const APP_TIMEZONE = 'Australia/Brisbane';

    let propertiesById = new Map();
    let gauges = [];
    let currentGauge = null;
    let currentYear  = null;
    let allowEditRain = false;
    let climatology   = null;  // loaded from consentes-house-rain.json

    function setStatus(msg, warn){
      statusEl.textContent = msg || '';
      statusEl.classList.toggle('status-warn', !!warn);
    }
    function setImportStatus(msg){ if (importStatus) importStatus.textContent = msg || ''; }
    function showOverlay(show){ authOverlay.style.display = show ? 'flex' : 'none'; }

    // ---------- Date helpers ----------
    function pad2(n){ return String(n).padStart(2,'0'); }

    function todayISO(){
      // Get "today" in Brisbane.
      const fmt = new Intl.DateTimeFormat('en-AU', {
        timeZone: APP_TIMEZONE,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
      const parts = fmt.formatToParts(new Date());
      const y = parts.find(p=>p.type==='year')?.value;
      const m = parts.find(p=>p.type==='month')?.value;
      const d = parts.find(p=>p.type==='day')?.value;
      return `${y}-${m}-${d}`;
    }

    function isoToUTCDate(iso){
      // Parse YYYY-MM-DD to Date at UTC midnight for safe day-diff math
      const m = String(iso||'').match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      return new Date(Date.UTC(Number(m[1]), Number(m[2]) - 1, Number(m[3])));
    }

    function daysBetweenISO(aIso, bIso){
      // b - a in days
      const a = isoToUTCDate(aIso);
      const b = isoToUTCDate(bIso);
      if (!a || !b) return null;
      const ms = b.getTime() - a.getTime();
      return Math.floor(ms / 86400000);
    }

    // Auth events
    signInBtn.onclick = async ()=>{
      const email = $('#siEmail').value.trim();
      const pass  = $('#siPass').value;
      const msgEl = $('#authMsg');
      if (!email || !pass){
        msgEl.textContent = 'Enter email and password.';
        return;
      }
      msgEl.textContent = 'Signing in…';
      try{
        await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        await auth.signInWithEmailAndPassword(email, pass);
        msgEl.textContent = 'Signed in.';
        showOverlay(false);
      }catch(e){
        console.error(e);
        msgEl.textContent = e && e.message ? e.message : 'Sign-in failed.';
      }
    };
    closeOverlayBtn.onclick = ()=> showOverlay(false);

    auth.onAuthStateChanged(async user=>{
      if (user){
        allowEditRain = true;
        showOverlay(false);
        if (showImport && importCard) importCard.style.display = 'block';
        try{ await db.enablePersistence({synchronizeTabs:true}); }catch(e){}
        await initPage();
      }else{
        allowEditRain = false;
        if (importCard) importCard.style.display = 'none';
        showOverlay(true);
        setStatus('Please sign in', true);
      }
    });

    async function initPage(){
      setStatus('Loading gauges…');
      await loadProperties();
      await loadGauges();
      initYears();
      await loadClimatology();
      setStatus('Ready');
      if (gaugeSel.value) await loadRainAndInsights();
    }

    async function loadProperties(){
      propertiesById.clear();
      const snap = await db.collection('properties').get();
      snap.forEach(doc=>{
        const d = doc.data() || {};
        propertiesById.set(doc.id, d.name || '(Property)');
      });
    }

    async function loadGauges(){
      gauges = [];
      const snap = await db.collection('gauges').get();
      snap.forEach(doc=>{
        const d = doc.data() || {};
        if (d.active === false) return;
        gauges.push({
          id: doc.id,
          name: d.name || '(Gauge)',
          propertyId: d.propertyId || null
        });
      });

      gauges.sort((a,b)=>{
        const pa = propertiesById.get(a.propertyId) || '';
        const pb = propertiesById.get(b.propertyId) || '';
        if (pa !== pb) return pa.localeCompare(pb);
        return a.name.localeCompare(b.name);
      });

      gaugeSel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = 'Select gauge…';
      gaugeSel.appendChild(opt0);

      gauges.forEach(g=>{
        const opt = document.createElement('option');
        opt.value = g.id;
        const propName = propertiesById.get(g.propertyId) || '';
        opt.textContent = propName ? `${propName} — ${g.name}` : g.name;
        gaugeSel.appendChild(opt);
      });

      const savedGaugeId = localStorage.getItem(ACTIVE_GAUGE_KEY) || '';
      if (savedGaugeId){
        const found = gauges.find(g=>g.id === savedGaugeId);
        if (found){
          gaugeSel.value = savedGaugeId;
          currentGauge = found;
        }
      }
      if (!currentGauge && gauges.length){
        currentGauge = gauges[0];
        gaugeSel.value = currentGauge.id;
      }
      updateGaugeInfo();
    }

    function initYears(){
      const now = new Date();
      const thisYear = now.getFullYear();
      const minYear = thisYear - 40;

      yearSel.innerHTML = '';
      for (let y=thisYear; y>=minYear; y--){
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = String(y);
        yearSel.appendChild(opt);
      }
      const savedYear = parseInt(localStorage.getItem(ACTIVE_YEAR_KEY) || '',10);
      if (savedYear && savedYear >= minYear && savedYear <= thisYear){
        yearSel.value = savedYear;
      }else{
        yearSel.value = thisYear;
      }
    }

    function updateGaugeInfo(){
      if (!currentGauge){
        gaugeInfo.textContent = '';
        return;
      }
      const propName = propertiesById.get(currentGauge.propertyId) || '';
      gaugeInfo.textContent = propName
        ? `Gauge "${currentGauge.name}" on ${propName}.`
        : `Gauge "${currentGauge.name}".`;
    }

    function makeEmptyYear(){
      const days = [];
      for (let d=0; d<31; d++) days.push(new Array(12).fill(null));
      return days;
    }

    function parseDateInfo(docId, data){
      const raw = data.dateISO || data.date || docId || '';
      if (typeof raw !== 'string') return null;
      const m = raw.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (!m) return null;
      const year  = parseInt(m[1],10);
      const month = parseInt(m[2],10);
      const day   = parseInt(m[3],10);
      if (!year || !month || !day) return null;
      return { year, month, day };
    }

    function extractMm(data){
      const v = data.mm ?? data.rainMm ?? data.amount ?? data.total ?? data.rainTotal ?? 0;
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    }

    async function updateRainDoc(gaugeId, year, month, day, mm){
      const dayStr   = String(day).padStart(2,'0');
      const monthStr = String(month).padStart(2,'0');
      const docId = `${year}-${monthStr}-${dayStr}`;
      const ref = db.collection('gauges').doc(gaugeId).collection('daily').doc(docId);

      if (mm == null){
        try{ await ref.delete(); }catch(e){ console.error('Failed to delete rain doc', e); }
      }else{
        const n = Number(mm);
        if (!Number.isFinite(n) || n < 0) throw new Error('Rainfall must be a non-negative number');
        await ref.set({
          mm: n,
          dateISO: docId,
          source: 'manualEdit',
          updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, {merge:true});
      }
    }

    async function loadRainAndInsights(){
      await loadRain();
      await loadInsightsForGauge();
    }

    // ---------- Fast year-only load ----------
    async function loadRain(){
      if (!currentGauge){ setStatus('No gauge selected', true); return; }
      const year = parseInt(yearSel.value,10);
      if (!year){ setStatus('Invalid year', true); return; }
      currentYear = year;

      setStatus('Loading rainfall…');
      rainHead.innerHTML = '';
      rainBody.innerHTML = '<tr><td colspan="13">Loading…</td></tr>';

      try{
        const baseRef = db.collection('gauges').doc(currentGauge.id).collection('daily');

        const startId = `${year}-01-01`;
        const endId   = `${year}-12-31`;

        const snap = await baseRef
          .where('dateISO', '>=', startId)
          .where('dateISO', '<=', endId)
          .get();

        const grid = makeEmptyYear();

        snap.forEach(doc=>{
          const data = doc.data() || {};
          const info = parseDateInfo(doc.id, data);
          if (!info || info.year !== year) return;
          const mm = extractMm(data);
          const dIdx = info.day - 1;
          const mIdx = info.month - 1;
          if (dIdx < 0 || dIdx >= 31 || mIdx < 0 || mIdx >= 12) return;
          grid[dIdx][mIdx] = (grid[dIdx][mIdx] || 0) + mm;
        });

        const stats = renderTable(grid);
        setStatus('Loaded');
        updateSummary(year, stats);
        // Store latest year grid stats so insights can use it too
        window.__sf_lastYearGrid = grid;
        window.__sf_lastYearStats = stats;
      }catch(e){
        console.error(e);
        rainBody.innerHTML = '<tr><td colspan="13">Error loading rainfall.</td></tr>';
        setStatus('Error loading rainfall.', true);
      }
    }

    function renderTable(grid){
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

      let headHtml = '<tr><th>Day</th>';
      for (let m=0; m<12; m++) headHtml += `<th>${months[m]}</th>`;
      headHtml += '</tr>';
      rainHead.innerHTML = headHtml;

      const monthTotals    = new Array(12).fill(0);
      const monthRainDays  = new Array(12).fill(0);

      function fmt(v){
        if (v == null || !Number.isFinite(v)) return '';
        const n = Number(v);
        return (Math.abs(n % 1) < 0.001) ? n.toFixed(0) : n.toFixed(1);
      }

      let bodyHtml = '';
      const canEdit = allowEditRain && !!currentGauge && !!currentYear;

      for (let d=0; d<31; d++){
        const day = d + 1;
        bodyHtml += `<tr><td>${day}</td>`;
        for (let m=0; m<12; m++){
          const v = grid[d][m];
          if (v != null && Number.isFinite(v)){
            monthTotals[m] += v;
            if (v >= RAIN_DAY_THRESHOLD_MM) monthRainDays[m] += 1;
          }
          const mmText = fmt(v);
          const cls = canEdit ? ' class="rain-cell-editable"' : '';
          bodyHtml += `<td data-day="${day}" data-month="${m+1}"${cls}>${mmText}</td>`;
        }
        bodyHtml += '</tr>';
      }

      bodyHtml += '<tr class="total-row"><td>Total rain (mm)</td>';
      for (let m=0; m<12; m++) bodyHtml += `<td>${fmt(monthTotals[m])}</td>`;
      bodyHtml += '</tr>';

      const cum = new Array(12).fill(0);
      for (let m=0; m<12; m++) cum[m] = (m === 0 ? monthTotals[m] : cum[m-1] + monthTotals[m]);
      bodyHtml += '<tr class="cum-row"><td>Cumulative total (mm)</td>';
      for (let m=0; m<12; m++) bodyHtml += `<td>${fmt(cum[m])}</td>`;
      bodyHtml += '</tr>';

      bodyHtml += `<tr><td>Rain days (≥${RAIN_DAY_THRESHOLD_MM} mm)</td>`;
      for (let m=0; m<12; m++) bodyHtml += `<td>${monthRainDays[m] || ''}</td>`;
      bodyHtml += '</tr>';

      rainBody.innerHTML = bodyHtml;

      if (canEdit){
        const gaugeId = currentGauge.id;
        const year    = currentYear;
        const cells = rainBody.querySelectorAll('td.rain-cell-editable');
        cells.forEach(td=>{
          td.addEventListener('click', async ()=>{
            const day   = parseInt(td.dataset.day,10);
            const month = parseInt(td.dataset.month,10);
            if (!day || !month) return;

            const existing = td.textContent.trim();
            const label = `${day}/${month}/${year}`;
            const input = window.prompt(`Rainfall for ${label} (mm). Leave blank to clear.`, existing);
            if (input === null) return;

            const trimmed = input.trim();
            try{
              if (!trimmed){
                await updateRainDoc(gaugeId, year, month, day, null);
              }else{
                const n = Number(trimmed);
                if (!Number.isFinite(n) || n < 0){ alert('Enter a non-negative number (mm).'); return; }
                await updateRainDoc(gaugeId, year, month, day, n);
              }
              await loadRainAndInsights();
            }catch(e){
              console.error(e);
              alert('Failed to save rainfall entry. Please try again.');
            }
          });
        });
      }

      return { monthTotals, monthRainDays };
    }

    async function loadClimatology(){
      try{
        const resp = await fetch('consentes-house-rain.json', {cache:'no-store'});
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        climatology = await resp.json();
      }catch(e){
        console.error('Failed to load consentes-house-rain.json', e);
        climatology = null;
        if (summaryContent) summaryContent.textContent = 'Long-term averages file not found or unreadable.';
      }
    }

    function updateSummary(year, stats){
      if (!summaryContent) return;

      const monthTotalsThisYear   = stats?.monthTotals   || [];
      const rainDaysThisYear      = stats?.monthRainDays || [];

      if (!currentGauge){
        summaryContent.textContent = 'Select a gauge and year to see summary.';
        return;
      }
      if (!climatology || !climatology.longTerm){
        summaryContent.textContent = 'Long-term averages not available. Create consentes-house-rain.json.';
        return;
      }

      const lt = climatology.longTerm;
      const ltaMonthly   = Array.isArray(lt.monthly) ? lt.monthly : [];
      const ltaRainDays  = Array.isArray(lt.monthlyRainDays) ? lt.monthlyRainDays : null;
      const ltaMedian    = Array.isArray(lt.monthlyMedian) ? lt.monthlyMedian : null;
      const ltaP10       = Array.isArray(lt.monthlyP10) ? lt.monthlyP10 : null;
      const ltaP90       = Array.isArray(lt.monthlyP90) ? lt.monthlyP90 : null;
      const seasons      = lt.seasons || lt.seasonal || null;
      const ltaAnnual    = (typeof lt.annual === 'number') ? lt.annual : null;
      const rainDayThreshold = (typeof lt.rainDayThresholdMm === 'number') ? lt.rainDayThresholdMm : null;
      const yearsList    = Array.isArray(lt.years) ? lt.years : null;

      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

      function fmt1(v){ return (v == null || !Number.isFinite(v)) ? '—' : Number(v).toFixed(1); }
      function fmt0(v){ return (v == null || !Number.isFinite(v)) ? '—' : String(Math.round(Number(v))); }
      function fmtPct(v){ return (v == null || !Number.isFinite(v)) ? '—' : Number(v).toFixed(0) + '%'; }

      const thisYearTotal = monthTotalsThisYear.reduce((a,b)=>a+(b||0),0);
      const yearPct = (ltaAnnual && ltaAnnual>0) ? (thisYearTotal / ltaAnnual * 100) : null;

      let html = '';
      html += `<div class="summary-item">
        <strong>${year} total</strong>
        <div>This year: ${fmt1(thisYearTotal)} mm</div>
        <div>Long-term annual: ${fmt1(ltaAnnual)} mm</div>
        <div>Year vs avg: ${fmtPct(yearPct)}</div>
        ${yearsList ? `<div class="muted small">Base period: ${yearsList[0]}–${yearsList[yearsList.length-1]} (${yearsList.length} yrs)</div>` : ''}
      </div>`;

      if (seasons && typeof seasons === 'object'){
        Object.keys(seasons).forEach(name=>{
          const s = seasons[name] || {};
          html += `<div class="summary-item">
            <strong>${name}</strong>
            <div>Mean: ${fmt1(s.mean)}</div>
            <div>Median: ${fmt1(s.median)}</div>
            <div>P10 dry: ${fmt1(s.p10)}</div>
            <div>P90 wet: ${fmt1(s.p90)}</div>
          </div>`;
        });
      }

      for (let m=0; m<12; m++){
        const thisM   = monthTotalsThisYear[m] || 0;
        const avgM    = (typeof ltaMonthly[m] === 'number') ? ltaMonthly[m] : null;
        const pct     = (avgM && avgM>0) ? (thisM / avgM * 100) : null;

        const rainDaysAvg = ltaRainDays && typeof ltaRainDays[m] === 'number' ? ltaRainDays[m] : null;
        const medianM = ltaMedian && typeof ltaMedian[m] === 'number' ? ltaMedian[m] : null;
        const p10M    = ltaP10 && typeof ltaP10[m] === 'number' ? ltaP10[m] : null;
        const p90M    = ltaP90 && typeof ltaP90[m] === 'number' ? ltaP90[m] : null;

        const thisRainDays = rainDaysThisYear[m] || 0;

        let cls = '';
        if (pct != null){
          if (pct < 60) cls = 'summary-bad';
          else if (pct > 140) cls = 'summary-good';
        }

        html += `<div class="summary-item ${cls}">
          <strong>${months[m]}</strong>
          <div>This year: ${fmt1(thisM)} mm</div>
          <div>Average: ${fmt1(avgM)} mm</div>
          <div>Pct of avg: ${fmtPct(pct)}</div>
          <div>Rain days this year: ${fmt0(thisRainDays)}</div>
          <div>Avg rain days: ${rainDaysAvg != null ? rainDaysAvg.toFixed(1) : '—'}${rainDayThreshold!=null ? ` (≥${rainDayThreshold} mm)` : ''}</div>
          ${medianM!=null ? `<div>Median: ${fmt1(medianM)} mm</div>` : ''}
          ${p10M!=null    ? `<div>P10 dry: ${fmt1(p10M)} mm</div>` : ''}
          ${p90M!=null    ? `<div>P90 wet: ${fmt1(p90M)} mm</div>` : ''}
        </div>`;
      }

      summaryContent.innerHTML = html;
    }

    // ---------- Insights (days since last rain, streaks, history records) ----------
    function fmt1(v){ return (v == null || !Number.isFinite(v)) ? '—' : Number(v).toFixed(1); }
    function fmt0(v){ return (v == null || !Number.isFinite(v)) ? '—' : String(Math.round(Number(v))); }

    async function loadInsightsForGauge(){
      if (!insightsContent) return;

      if (!currentGauge){
        insightsContent.innerHTML = `<div class="summary-item">Select a gauge.</div>`;
        return;
      }

      // Always show something immediately using the currently loaded year grid
      const year = parseInt(yearSel.value,10) || null;
      const grid = window.__sf_lastYearGrid || null;
      const stats = window.__sf_lastYearStats || null;

      const quick = computeQuickYearInsights(year, grid, stats);
      const recent = await computeRecentInsights(currentGauge.id);
      const cachedHistory = getCachedHistoryStats(currentGauge.id);

      let html = '';

      html += `<div class="summary-item">
        <strong>Today</strong>
        <div>Date: ${todayISO()}</div>
        <div>Rain day threshold: ≥${RAIN_DAY_THRESHOLD_MM} mm</div>
      </div>`;

      html += `<div class="summary-item">
        <strong>Since last rain</strong>
        <div>Days since last rain: ${recent.daysSinceLastRain != null ? fmt0(recent.daysSinceLastRain) : '—'}</div>
        <div>Last rain: ${recent.lastRainISO ? recent.lastRainISO : '—'} (${recent.lastRainMm != null ? fmt1(recent.lastRainMm) + ' mm' : '—'})</div>
        <div>Current dry streak: ${recent.currentDryStreakDays != null ? fmt0(recent.currentDryStreakDays) + ' days' : '—'}</div>
      </div>`;

      html += `<div class="summary-item">
        <strong>Recent totals</strong>
        <div>Last 7 days: ${fmt1(recent.sum7)} mm</div>
        <div>Last 30 days: ${fmt1(recent.sum30)} mm</div>
        <div>Last 90 days: ${fmt1(recent.sum90)} mm</div>
        <div>Rain days (30d): ${fmt0(recent.rainDays30)}</div>
      </div>`;

      if (quick){
        html += `<div class="summary-item">
          <strong>${year} snapshot</strong>
          <div>Total: ${fmt1(quick.total)} mm</div>
          <div>Rain days: ${fmt0(quick.rainDays)}</div>
          <div>Wettest day: ${quick.wettestDayISO || '—'} (${quick.wettestDayMm != null ? fmt1(quick.wettestDayMm) + ' mm' : '—'})</div>
        </div>`;
      }

      if (cachedHistory){
        html += `<div class="summary-item">
          <strong>All-time dry record</strong>
          <div>Longest dry streak: ${fmt0(cachedHistory.longestDryDays)} days</div>
          <div>${cachedHistory.longestDryStart || '—'} to ${cachedHistory.longestDryEnd || '—'}</div>
          <div class="muted small">Cached: ${cachedHistory.cachedAt || '—'}</div>
        </div>`;

        html += `<div class="summary-item">
          <strong>All-time wettest day</strong>
          <div>${cachedHistory.wettestDayISO || '—'}</div>
          <div>${cachedHistory.wettestDayMm != null ? fmt1(cachedHistory.wettestDayMm) + ' mm' : '—'}</div>
          <div class="muted small">Tip: hit "Refresh history stats" after big imports.</div>
        </div>`;
      }else{
        html += `<div class="summary-item">
          <strong>All-time records</strong>
          <div class="muted">Not cached yet on this device.</div>
          <div>Click "Refresh history stats" to compute longest dry streak and records.</div>
        </div>`;
      }

      // Known missing record years for Consentes dataset, keep it visible but not intrusive
      html += `<div class="summary-item">
        <strong>Data notes</strong>
        <div>Known missing years: 1989, 2001 (no record)</div>
        <div class="muted small">These are intentionally left blank, not back-filled.</div>
      </div>`;

      insightsContent.innerHTML = html;
    }

    function computeQuickYearInsights(year, grid, stats){
      if (!year || !grid || !stats) return null;

      const total = (stats.monthTotals || []).reduce((a,b)=>a+(b||0),0);
      const rainDays = (stats.monthRainDays || []).reduce((a,b)=>a+(b||0),0);

      // Wettest day in the loaded year grid
      let best = { mm: -1, iso: null };
      for (let m=1; m<=12; m++){
        for (let d=1; d<=31; d++){
          const v = grid[d-1]?.[m-1];
          if (v == null || !Number.isFinite(v)) continue;
          if (v > best.mm){
            best.mm = v;
            best.iso = `${year}-${pad2(m)}-${pad2(d)}`;
          }
        }
      }

      return {
        total,
        rainDays,
        wettestDayISO: best.iso,
        wettestDayMm: best.mm >= 0 ? best.mm : null
      };
    }

    async function computeRecentInsights(gaugeId){
      // Pull last ~400 days docs and compute last rain and rolling sums.
      // Missing days are treated as 0 for rolling sums.
      const baseRef = db.collection('gauges').doc(gaugeId).collection('daily');

      // Fetch recent docs by dateISO descending
      const snap = await baseRef.orderBy('dateISO', 'desc').limit(500).get();

      const today = todayISO();

      // Map for quick lookup of mm by dateISO
      const mmByISO = new Map();
      let lastSeenISO = null;

      snap.forEach(doc=>{
        const d = doc.data() || {};
        const iso = d.dateISO || doc.id;
        if (typeof iso === 'string' && iso.match(/^\d{4}-\d{2}-\d{2}$/)){
          mmByISO.set(iso, extractMm(d));
          if (!lastSeenISO) lastSeenISO = iso;
        }
      });

      // Find last rain day within fetched window
      let lastRainISO = null;
      let lastRainMm = null;

      // We need to walk backward from today to find a rain day, because
      // there may be missing days with no docs (assume 0).
      const maxLookbackDays = 500; // enough for "days since last rain" in practice
      let currentDryStreakDays = 0;

      for (let i=0; i<=maxLookbackDays; i++){
        const iso = addDaysISO(today, -i);
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;

        if (i === 0){
          // determine current dry streak starting today
          if (mm < RAIN_DAY_THRESHOLD_MM){
            currentDryStreakDays = 1;
            for (let j=1; j<=maxLookbackDays; j++){
              const iso2 = addDaysISO(today, -j);
              const mm2 = mmByISO.has(iso2) ? Number(mmByISO.get(iso2) || 0) : 0;
              if (mm2 < RAIN_DAY_THRESHOLD_MM) currentDryStreakDays++;
              else break;
            }
          }else{
            currentDryStreakDays = 0;
          }
        }

        if (mm >= RAIN_DAY_THRESHOLD_MM){
          lastRainISO = iso;
          lastRainMm = mm;
          break;
        }
      }

      const daysSinceLastRain = lastRainISO ? daysBetweenISO(lastRainISO, today) : null;

      // Rolling sums (7/30/90) + rain days in last 30
      let sum7 = 0, sum30 = 0, sum90 = 0, rainDays30 = 0;
      for (let i=0; i<90; i++){
        const iso = addDaysISO(today, -i);
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;
        if (i < 7) sum7 += mm;
        if (i < 30){
          sum30 += mm;
          if (mm >= RAIN_DAY_THRESHOLD_MM) rainDays30 += 1;
        }
        sum90 += mm;
      }

      return {
        lastRainISO,
        lastRainMm,
        daysSinceLastRain,
        currentDryStreakDays,
        sum7,
        sum30,
        sum90,
        rainDays30
      };
    }

    function addDaysISO(iso, deltaDays){
      const d = isoToUTCDate(iso);
      if (!d) return iso;
      const out = new Date(d.getTime() + deltaDays * 86400000);
      const y = out.getUTCFullYear();
      const m = pad2(out.getUTCMonth() + 1);
      const da = pad2(out.getUTCDate());
      return `${y}-${m}-${da}`;
    }

    function getCachedHistoryStats(gaugeId){
      try{
        const key = `sf.rainHistoryStats.${gaugeId}`;
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return null;
        return parsed;
      }catch(e){
        return null;
      }
    }

    function setCachedHistoryStats(gaugeId, stats){
      try{
        const key = `sf.rainHistoryStats.${gaugeId}`;
        localStorage.setItem(key, JSON.stringify(stats));
      }catch(e){}
    }

    async function computeAndCacheHistoryStats(gaugeId){
      // Warning: reads every rainfall doc for this gauge.
      setStatus('Computing history stats…');
      insightsContent.innerHTML = `<div class="summary-item">Computing history stats. This reads all rainfall docs for the gauge.</div>`;

      const baseRef = db.collection('gauges').doc(gaugeId).collection('daily');
      const snap = await baseRef.orderBy('dateISO', 'asc').get();

      // Map dateISO -> mm, and detect range
      const mmByISO = new Map();
      let firstISO = null;
      let lastISO = null;

      snap.forEach(doc=>{
        const d = doc.data() || {};
        const iso = d.dateISO || doc.id;
        if (typeof iso !== 'string' || !iso.match(/^\d{4}-\d{2}-\d{2}$/)) return;
        const mm = extractMm(d);
        mmByISO.set(iso, mm);
        if (!firstISO) firstISO = iso;
        lastISO = iso;
      });

      if (!firstISO || !lastISO){
        setStatus('No rainfall history found', true);
        setCachedHistoryStats(gaugeId, null);
        return null;
      }

      // Walk day by day across full range, treating missing days as 0
      let longestDryDays = 0;
      let longestDryStart = null;
      let longestDryEnd = null;

      let curDryDays = 0;
      let curDryStart = null;

      let wettestDayISO = null;
      let wettestDayMm = -1;

      let iso = firstISO;
      while (true){
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;

        if (mm > wettestDayMm){
          wettestDayMm = mm;
          wettestDayISO = iso;
        }

        if (mm < RAIN_DAY_THRESHOLD_MM){
          if (curDryDays === 0) curDryStart = iso;
          curDryDays += 1;
        }else{
          if (curDryDays > longestDryDays){
            longestDryDays = curDryDays;
            longestDryStart = curDryStart;
            longestDryEnd = addDaysISO(iso, -1);
          }
          curDryDays = 0;
          curDryStart = null;
        }

        if (iso === lastISO) break;
        iso = addDaysISO(iso, 1);
      }

      // If the series ended during a dry streak, close it
      if (curDryDays > longestDryDays){
        longestDryDays = curDryDays;
        longestDryStart = curDryStart;
        longestDryEnd = lastISO;
      }

      const cachedAt = new Date().toISOString();

      const out = {
        longestDryDays,
        longestDryStart,
        longestDryEnd,
        wettestDayISO,
        wettestDayMm: wettestDayMm >= 0 ? wettestDayMm : null,
        firstISO,
        lastISO,
        cachedAt
      };

      setCachedHistoryStats(gaugeId, out);
      setStatus('History stats updated');
      return out;
    }

    refreshHistoryBtn.onclick = async ()=>{
      if (!currentGauge) return;
      try{
        await computeAndCacheHistoryStats(currentGauge.id);
        await loadInsightsForGauge();
      }catch(e){
        console.error(e);
        setStatus('Failed to compute history stats', true);
        alert('Failed to compute history stats. Check console for details.');
      }
    };

    // ---------- UI events ----------
    reloadBtn.onclick = async ()=>{
      if (!gaugeSel.value) return;
      const year = parseInt(yearSel.value,10);
      if (year) localStorage.setItem(ACTIVE_YEAR_KEY, String(year));
      localStorage.setItem(ACTIVE_GAUGE_KEY, gaugeSel.value);
      currentGauge = gauges.find(g=>g.id === gaugeSel.value) || null;
      updateGaugeInfo();
      await loadRainAndInsights();
    };
    gaugeSel.onchange = ()=> reloadBtn.click();
    yearSel.onchange  = ()=> reloadBtn.click();
    printBtn.onclick  = ()=> window.print();

    // ---------- Importer (year sheets with day rows and month columns) ----------
    if (importBtn){
      importBtn.onclick = async ()=>{
        const file = importFile.files[0];
        if (!file){ setImportStatus('Choose an .xlsx file first.'); return; }
        if (!currentGauge){ setImportStatus('Select a gauge to import into.'); return; }

        try{
          setImportStatus('Reading workbook…');
          const data = await file.arrayBuffer();
          const wb = XLSX.read(data, {type:'array'});

          const gaugeId = currentGauge.id;
          let totalWrites = 0;
          let totalSheets = 0;

          // Prefer sheets that look like years (e.g. "1968", "2025")
          const yearSheets = wb.SheetNames
            .map(name=>({name, year: parseInt(String(name).trim(),10)}))
            .filter(x=>Number.isFinite(x.year) && x.year >= 1900 && x.year <= 3000)
            .sort((a,b)=>a.year - b.year);

          if (!yearSheets.length){
            throw new Error('No year-named sheets found (e.g. "1968").');
          }

          for (const s of yearSheets){
            const sheet = wb.Sheets[s.name];
            if (!sheet) continue;
            setImportStatus(`Importing sheet ${s.name}…`);
            const writes = await importYearSheetGrid(gaugeId, s.year, sheet);
            totalWrites += writes;
            totalSheets += 1;
          }

          setImportStatus(`Import complete: ${totalWrites} day entries written across ${totalSheets} sheets.`);
          await loadRainAndInsights();
        }catch(e){
          console.error(e);
          setImportStatus('Import failed: ' + (e && e.message ? e.message : e));
        }
      };
    }

    async function importYearSheetGrid(gaugeId, year, sheet){
      // Expected layout (like your workbook):
      // Row 1: [blank, January, February, ... December]
      // Col A: day number 1..31
      // Cols B..M: rainfall values (mm), blanks allowed
      const rows = XLSX.utils.sheet_to_json(sheet, {header:1, raw:true});
      if (!rows || rows.length < 2) return 0;

      // Detect month columns from header row 0
      const header = rows[0] || [];
      const monthMap = detectMonthColumns(header);
      // monthMap: array of {month:1..12, colIndex}

      if (monthMap.length < 6){
        // Fallback: assume B..M
        monthMap.length = 0;
        for (let m=1; m<=12; m++) monthMap.push({month:m, colIndex:m}); // 1->B etc
      }

      const baseRef = db.collection('gauges').doc(gaugeId).collection('daily');

      let batch = db.batch();
      let writes = 0;

      for (let r=1; r<rows.length; r++){
        const row = rows[r] || [];
        const day = Number(row[0]);
        if (!Number.isFinite(day) || day < 1 || day > 31) continue;

        for (const mc of monthMap){
          const raw = row[mc.colIndex];
          if (raw == null || raw === '') continue;

          const mm = Number(raw);
          if (!Number.isFinite(mm) || mm < 0) continue;

          const iso = `${year}-${pad2(mc.month)}-${pad2(day)}`;
          const ref = baseRef.doc(iso);

          batch.set(ref, {
            mm,
            dateISO: iso,
            source: 'excelImport',
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
          }, {merge:true});

          writes++;
          if (writes % 450 === 0){
            await batch.commit();
            batch = db.batch();
          }
        }
      }

      if (writes % 450 !== 0){
        await batch.commit();
      }

      return writes;
    }

    function detectMonthColumns(headerRow){
      const months = [
        {m:1, names:['jan','january']},
        {m:2, names:['feb','february']},
        {m:3, names:['mar','march']},
        {m:4, names:['apr','april']},
        {m:5, names:['may']},
        {m:6, names:['jun','june']},
        {m:7, names:['jul','july']},
        {m:8, names:['aug','august']},
        {m:9, names:['sep','sept','september']},
        {m:10, names:['oct','october']},
        {m:11, names:['nov','november']},
        {m:12, names:['dec','december']}
      ];

      const out = [];
      for (let c=0; c<headerRow.length; c++){
        const cell = String(headerRow[c] ?? '').trim().toLowerCase();
        if (!cell) continue;
        for (const mm of months){
          if (mm.names.some(n=>cell.includes(n))){
            out.push({month:mm.m, colIndex:c});
            break;
          }
        }
      }

      // Sort by month
      out.sort((a,b)=>a.month - b.month);
      return out;
    }
  </script>
</body>
</html>
