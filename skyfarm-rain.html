<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SkyFarm — Rainfall</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="skyfarm-shared.css">

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --line:#e5e7eb;
      --brand:#0B7A6E;
      --danger:#b91c1c;
      --focus:#2563eb;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      padding:0;
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text",system-ui,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#e0f2fe 0,#f6fbf8 40%,#f6fbf8 100%);
      color:var(--ink);
      -webkit-font-smoothing:antialiased;
    }
    a{text-decoration:none;color:inherit;}
    button{cursor:pointer;}
    .muted{color:var(--muted);}
    .small{font-size:.8rem;}
    .wrap{max-width:1100px;margin:0 auto;padding:12px 12px 40px;}
    h1{margin:12px 0;font-size:1.45rem;}
    .card{
      background:var(--card);
      border-radius:12px;
      border:1px solid var(--line);
      padding:12px;
      margin:10px 0;
    }
    .row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;}
    label{font-size:.82rem;color:#475569;display:block;margin-bottom:3px;}
    select,input,button{
      font-family:inherit;
      font-size:.9rem;
      border-radius:10px;
      border:1px solid #cbd5e1;
      padding:6px 9px;
      background:#fff;
    }
    select:focus,input:focus,button:focus{
      outline:none;
      border-color:var(--focus);
      box-shadow:0 0 0 1px rgba(37,99,235,.2);
    }
    .btn{
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:.85rem;
      padding:5px 10px;
    }
    .btn.primary{background:var(--brand);border-color:var(--brand);color:#fff;}
    #status{font-size:.8rem;}
    .status-warn{color:var(--danger);}

    table{width:100%;border-collapse:collapse;margin-top:4px;font-size:.76rem;}
    th,td{border:1px solid #e5e7eb;padding:4px 5px;text-align:right;}
    th{background:#f9fafb;font-weight:600;color:#4b5563;}
    td:first-child,th:first-child{
      text-align:left;position:sticky;left:0;background:#f9fafb;z-index:1;
    }
    tr:nth-child(even) td:first-child{background:#f3f4f6;}
    td.rain-cell-editable{cursor:pointer;background:#f8fafc;}
    .total-row td{font-weight:600;background:#eff6ff;}
    .cum-row td{background:#ecfdf3;}

    .summary{
      margin-top:12px;border-radius:12px;border:1px dashed #cbd5e1;
      padding:10px 12px;background:#f9fafb;
    }
    .summary-grid{
      margin-top:8px;display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:8px;
    }
    .summary-item{
      border-radius:10px;background:#fff;border:1px solid #e5e7eb;
      padding:7px 9px;font-size:.78rem;
    }
    .summary-good{border-color:#16a34a;background:#f0fdf4;}
    .summary-bad{border-color:#f97316;background:#fff7ed;}
    .summary-actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;}

    #authOverlay{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(15,23,42,.08);z-index:2000;
    }
    #authCard{
      width:min(520px,92vw);background:#fff;border-radius:16px;border:1px solid var(--line);
      padding:18px 16px 14px;box-shadow:0 18px 45px rgba(15,23,42,.22);
    }
    #authCard h2{margin:0 0 6px;font-size:1.1rem;}

    @media (max-width:640px){
      .wrap{padding-inline:9px;}
      table{font-size:.7rem;}
    }
  </style>
</head>

<body>
  <div id="sf-header-root"></div>

  <div class="wrap">
    <h1>Rainfall</h1>

    <div class="card">
      <div class="row">
        <div>
          <label>Gauge</label>
          <select id="gaugeSel"><option value="">Loading gauges…</option></select>
        </div>
        <div>
          <label>Year</label>
          <select id="yearSel"></select>
        </div>
        <button id="reloadBtn" class="btn" type="button">Reload</button>
        <button id="printBtn" class="btn primary" type="button">Print / PDF</button>
        <span style="flex:1;"></span>
        <span id="status" class="muted small">Loading…</span>
      </div>
      <div id="gaugeInfo" class="muted small" style="margin-top:4px;"></div>
    </div>

    <div class="card">
      <div style="overflow-x:auto;">
        <table>
          <thead id="rainHead"></thead>
          <tbody id="rainBody"><tr><td colspan="13">Loading…</td></tr></tbody>
        </table>
      </div>
    </div>

    <div class="summary">
      <div class="row" style="justify-content:space-between;gap:10px;">
        <div class="muted small">Quick insights for the selected gauge.</div>
        <div class="summary-actions">
          <button id="refreshHistoryBtn" class="btn" type="button" title="Reads rainfall docs for this gauge in pages and caches results in this browser.">
            Refresh history stats
          </button>
        </div>
      </div>
      <div id="insightsContent" class="summary-grid small">
        <div>Loading insights…</div>
      </div>
    </div>

    <div class="summary">
      <div class="muted small">Monthly and long-term rainfall for the selected gauge and year.</div>
      <div id="summaryContent" class="summary-grid small">
        <div>Loading climatology…</div>
      </div>
    </div>
  </div>

  <!-- Auth overlay -->
  <div id="authOverlay">
    <div id="authCard">
      <h2>Sign in to SkyFarm</h2>
      <p class="muted small" style="margin-bottom:8px;">
        Email &amp; password only. Editing rain requires sign-in.
      </p>
      <div class="row" style="margin-bottom:6px;">
        <div style="flex:1;min-width:220px;">
          <label>Email</label>
          <input id="siEmail" type="email" autocomplete="username" placeholder="you@example.com" />
        </div>
        <div style="flex:1;min-width:180px;">
          <label>Password</label>
          <input id="siPass" type="password" autocomplete="current-password" placeholder="••••••••" />
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;">
        <button id="signInBtn" class="btn primary" type="button">Sign in</button>
        <button id="closeOverlayBtn" class="btn" type="button">Close</button>
        <span id="authMsg" class="muted small" style="margin-left:8px;"></span>
      </div>
    </div>
  </div>

  <script src="skyfarm-header.js"></script>

  <script>
    // ---------- Firebase init ----------
    const firebaseConfig = {
      apiKey: "AIzaSyBO9_0v1HdvVDuK3EFvaBGvQJIGvBwmW70",
      authDomain: "consentes-pastoral.firebaseapp.com",
      projectId: "consentes-pastoral",
      appId: "1:494858780013:web:d87497b370c82eeab06e64"
    };
    firebase.initializeApp(firebaseConfig);
    const db   = firebase.firestore();
    const auth = firebase.auth();
    try { window.SkyFarmHeader && SkyFarmHeader.mount(); } catch(e){ console.warn(e); }

    const $ = s => document.querySelector(s);

    const statusEl        = $('#status');
    const rainHead        = $('#rainHead');
    const rainBody        = $('#rainBody');
    const summaryContent  = $('#summaryContent');
    const insightsContent = $('#insightsContent');
    const gaugeInfo       = $('#gaugeInfo');

    const authOverlay     = $('#authOverlay');
    const signInBtn       = $('#signInBtn');
    const closeOverlayBtn = $('#closeOverlayBtn');

    const gaugeSel  = $('#gaugeSel');
    const yearSel   = $('#yearSel');
    const reloadBtn = $('#reloadBtn');
    const printBtn  = $('#printBtn');
    const refreshHistoryBtn = $('#refreshHistoryBtn');

    const ACTIVE_GAUGE_KEY = 'sf.activeGaugeId';
    const ACTIVE_YEAR_KEY  = 'sf.activeRainYear';

    // You asked for 0.5mm rain day threshold
    const RAIN_DAY_THRESHOLD_MM = 0.5;

    const APP_TIMEZONE = 'Australia/Brisbane';

    let propertiesById = new Map();
    let gauges = [];
    let currentGauge = null;
    let currentYear  = null;
    let allowEditRain = false;
    let climatology   = null;

    // year label info
    let knownNoRecordYears = new Set();

    function setStatus(msg, warn){
      statusEl.textContent = msg || '';
      statusEl.classList.toggle('status-warn', !!warn);
    }
    function showOverlay(show){ authOverlay.style.display = show ? 'flex' : 'none'; }

    // ---------- Date helpers ----------
    const pad2 = n => String(n).padStart(2,'0');

    function todayISO(){
      const fmt = new Intl.DateTimeFormat('en-AU', {
        timeZone: APP_TIMEZONE, year:'numeric', month:'2-digit', day:'2-digit'
      });
      const parts = fmt.formatToParts(new Date());
      const y = parts.find(p=>p.type==='year')?.value;
      const m = parts.find(p=>p.type==='month')?.value;
      const d = parts.find(p=>p.type==='day')?.value;
      return `${y}-${m}-${d}`;
    }

    function isoToUTCDate(iso){
      const m = String(iso||'').match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return null;
      return new Date(Date.UTC(Number(m[1]), Number(m[2]) - 1, Number(m[3])));
    }
    function addDaysISO(iso, deltaDays){
      const d = isoToUTCDate(iso);
      if (!d) return iso;
      const out = new Date(d.getTime() + deltaDays * 86400000);
      return `${out.getUTCFullYear()}-${pad2(out.getUTCMonth()+1)}-${pad2(out.getUTCDate())}`;
    }
    function daysBetweenISO(aIso, bIso){
      const a = isoToUTCDate(aIso);
      const b = isoToUTCDate(bIso);
      if (!a || !b) return null;
      return Math.floor((b.getTime() - a.getTime()) / 86400000);
    }

    // ---------- Auth ----------
    signInBtn.onclick = async ()=>{
      const email = $('#siEmail').value.trim();
      const pass  = $('#siPass').value;
      const msgEl = $('#authMsg');
      if (!email || !pass){ msgEl.textContent = 'Enter email and password.'; return; }
      msgEl.textContent = 'Signing in…';
      try{
        await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        await auth.signInWithEmailAndPassword(email, pass);
        msgEl.textContent = 'Signed in.';
        showOverlay(false);
      }catch(e){
        console.error(e);
        msgEl.textContent = e?.message || 'Sign-in failed.';
      }
    };
    closeOverlayBtn.onclick = ()=> showOverlay(false);

    auth.onAuthStateChanged(async user=>{
      if (user){
        allowEditRain = true;
        showOverlay(false);
        knownNoRecordYears = new Set();
        try{ await db.enablePersistence({synchronizeTabs:true}); }catch(e){}
        await initPage();
      }else{
        allowEditRain = false;
        showOverlay(true);
        setStatus('Please sign in', true);
      }
    });

    // ---------- Init ----------
    async function initPage(){
      setStatus('Loading gauges…');
      await loadProperties();
      await loadGauges();
      await loadClimatology();
      setStatus('Ready');
      if (gaugeSel.value) await rebuildYearsFromDataAndLoad();
    }

    async function loadProperties(){
      propertiesById.clear();
      const snap = await db.collection('properties').get();
      snap.forEach(doc=>{
        const d = doc.data() || {};
        propertiesById.set(doc.id, d.name || '(Property)');
      });
    }

    async function loadGauges(){
      gauges = [];
      const snap = await db.collection('gauges').get();
      snap.forEach(doc=>{
        const d = doc.data() || {};
        if (d.active === false) return;
        gauges.push({ id: doc.id, name: d.name || '(Gauge)', propertyId: d.propertyId || null });
      });

      gauges.sort((a,b)=>{
        const pa = propertiesById.get(a.propertyId) || '';
        const pb = propertiesById.get(b.propertyId) || '';
        if (pa !== pb) return pa.localeCompare(pb);
        return a.name.localeCompare(b.name);
      });

      gaugeSel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = 'Select gauge…';
      gaugeSel.appendChild(opt0);

      gauges.forEach(g=>{
        const opt = document.createElement('option');
        opt.value = g.id;
        const propName = propertiesById.get(g.propertyId) || '';
        opt.textContent = propName ? `${propName} — ${g.name}` : g.name;
        gaugeSel.appendChild(opt);
      });

      const savedGaugeId = localStorage.getItem(ACTIVE_GAUGE_KEY) || '';
      if (savedGaugeId){
        const found = gauges.find(g=>g.id === savedGaugeId);
        if (found){ gaugeSel.value = savedGaugeId; currentGauge = found; }
      }
      if (!currentGauge && gauges.length){
        currentGauge = gauges[0];
        gaugeSel.value = currentGauge.id;
      }
      updateGaugeInfo();
    }

    function updateGaugeInfo(){
      if (!currentGauge){ gaugeInfo.textContent = ''; return; }
      const propName = propertiesById.get(currentGauge.propertyId) || '';
      gaugeInfo.textContent = propName
        ? `Gauge "${currentGauge.name}" on ${propName}.`
        : `Gauge "${currentGauge.name}".`;
    }

    async function loadClimatology(){
      try{
        const resp = await fetch('consentes-house-rain.json', {cache:'no-store'});
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        climatology = await resp.json();
      }catch(e){
        console.warn('No climatology file:', e);
        climatology = null;
      }
    }

    // ---------- Year dropdown from data + "no record" labels ----------
    async function getGaugeYearBounds(gaugeId){
      const col = db.collection('gauges').doc(gaugeId).collection('daily');
      const idField = firebase.firestore.FieldPath.documentId();

      const firstSnap = await col.orderBy(idField, 'asc').limit(1).get();
      const lastSnap  = await col.orderBy(idField, 'desc').limit(1).get();

      if (firstSnap.empty || lastSnap.empty) return null;

      const firstId = firstSnap.docs[0].id;
      const lastId  = lastSnap.docs[0].id;

      const y1 = parseInt(firstId.slice(0,4),10);
      const y2 = parseInt(lastId.slice(0,4),10);
      if (!Number.isFinite(y1) || !Number.isFinite(y2)) return null;

      return { minYear: Math.min(y1,y2), maxYear: Math.max(y1,y2) };
    }

    function buildYears(minYear, maxYear){
      yearSel.innerHTML = '';
      for (let y=maxYear; y>=minYear; y--){
        const opt = document.createElement('option');
        opt.value = y;
        opt.textContent = String(y);
        yearSel.appendChild(opt);
      }
    }

    async function getYearsWithAnyDocsPaged(gaugeId){
      const col = db.collection('gauges').doc(gaugeId).collection('daily');
      const idField = firebase.firestore.FieldPath.documentId();

      const years = new Set();
      let lastDoc = null;
      let page = 0;

      while (true){
        let q = col.orderBy(idField, 'asc').limit(500);
        if (lastDoc) q = q.startAfter(lastDoc);
        const snap = await q.get();
        page++;
        if (snap.empty) break;

        snap.forEach(doc=>{
          const id = doc.id;
          if (/^\d{4}-\d{2}-\d{2}$/.test(id)){
            years.add(id.slice(0,4));
          }
        });

        lastDoc = snap.docs[snap.docs.length - 1];
        if (page > 2000) break;
      }

      return years; // Set of "YYYY"
    }

    function markMissingYearsInDropdown(yearsWithDocs){
      knownNoRecordYears = new Set();
      [...yearSel.options].forEach(opt=>{
        const y = String(opt.value);
        if (!yearsWithDocs.has(y)){
          opt.textContent = `${y} (no record)`;
          knownNoRecordYears.add(parseInt(y,10));
        }else{
          opt.textContent = y;
        }
      });
    }

    async function rebuildYearsFromDataAndLoad(){
      if (!currentGauge) return;

      setStatus('Loading years…');
      let bounds = null;
      try{ bounds = await getGaugeYearBounds(currentGauge.id); }catch(e){ console.error(e); }

      const now = new Date();
      const thisYear = now.getFullYear();

      if (bounds){
        buildYears(bounds.minYear, bounds.maxYear);
        try{
          const yearsWithDocs = await getYearsWithAnyDocsPaged(currentGauge.id);
          markMissingYearsInDropdown(yearsWithDocs);
        }catch(e){
          console.error('Failed to label missing years', e);
        }
      }else{
        buildYears(thisYear - 40, thisYear);
      }

      const savedYear = parseInt(localStorage.getItem(ACTIVE_YEAR_KEY) || '',10);
      const minY = parseInt(yearSel.lastElementChild?.value || '',10);
      const maxY = parseInt(yearSel.firstElementChild?.value || '',10);

      if (savedYear && savedYear >= minY && savedYear <= maxY){
        yearSel.value = savedYear;
      }else{
        yearSel.value = String(bounds?.maxYear || thisYear);
      }

      await loadRainAndInsights();
      setStatus('Ready');
    }

    // ---------- Rain table ----------
    function makeEmptyYear(){
      const days = [];
      for (let d=0; d<31; d++) days.push(new Array(12).fill(null));
      return days;
    }

    function extractMm(data){
      const n = Number(data?.mm ?? 0);
      return Number.isFinite(n) ? n : 0;
    }

    async function updateRainDoc(gaugeId, year, month, day, mm){
      const docId = `${year}-${pad2(month)}-${pad2(day)}`;
      const ref = db.collection('gauges').doc(gaugeId).collection('daily').doc(docId);

      if (mm == null){
        await ref.delete();
      }else{
        const n = Number(mm);
        if (!Number.isFinite(n) || n < 0) throw new Error('Rainfall must be a non-negative number');
        await ref.set({
          mm: n,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          source: 'manualEdit'
        }, {merge:true});
      }
    }

    async function loadRain(){
      if (!currentGauge){ setStatus('No gauge selected', true); return; }
      const year = parseInt(yearSel.value,10);
      if (!year){ setStatus('Invalid year', true); return; }
      currentYear = year;

      setStatus('Loading rainfall…');
      rainHead.innerHTML = '';
      rainBody.innerHTML = '<tr><td colspan="13">Loading…</td></tr>';

      try{
        const col = db.collection('gauges').doc(currentGauge.id).collection('daily');
        const idField = firebase.firestore.FieldPath.documentId();

        const startId = `${year}-01-01`;
        const endId   = `${year}-12-31`;

        const snap = await col
          .orderBy(idField)
          .startAt(startId)
          .endAt(endId)
          .get();

        const grid = makeEmptyYear();

        snap.forEach(doc=>{
          const id = doc.id;
          const m = id.match(/^(\d{4})-(\d{2})-(\d{2})$/);
          if (!m) return;
          const mm = extractMm(doc.data() || {});
          const month = parseInt(m[2],10);
          const day   = parseInt(m[3],10);
          const dIdx = day - 1;
          const mIdx = month - 1;
          if (dIdx<0||dIdx>=31||mIdx<0||mIdx>=12) return;
          grid[dIdx][mIdx] = (grid[dIdx][mIdx] || 0) + mm;
        });

        const stats = renderTable(grid);
        window.__sf_lastYearGrid = grid;
        window.__sf_lastYearStats = stats;

        setStatus('Loaded');
        updateSummary(year, stats);
      }catch(e){
        console.error(e);
        rainBody.innerHTML = '<tr><td colspan="13">Error loading rainfall.</td></tr>';
        setStatus('Error loading rainfall.', true);
      }
    }

    function renderTable(grid){
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

      let headHtml = '<tr><th>Day</th>';
      for (let m=0; m<12; m++) headHtml += `<th>${months[m]}</th>`;
      headHtml += '</tr>';
      rainHead.innerHTML = headHtml;

      const monthTotals = new Array(12).fill(0);
      const monthRainDays = new Array(12).fill(0);

      function fmt(v){
        if (v == null || !Number.isFinite(v)) return '';
        const n = Number(v);
        return (Math.abs(n % 1) < 0.001) ? n.toFixed(0) : n.toFixed(1);
      }

      let bodyHtml = '';
      const canEdit = allowEditRain && !!currentGauge && !!currentYear;

      for (let d=0; d<31; d++){
        const day = d + 1;
        bodyHtml += `<tr><td>${day}</td>`;
        for (let m=0; m<12; m++){
          const v = grid[d][m];
          if (v != null && Number.isFinite(v)){
            monthTotals[m] += v;
            if (v >= RAIN_DAY_THRESHOLD_MM) monthRainDays[m] += 1;
          }
          const cls = canEdit ? ' class="rain-cell-editable"' : '';
          bodyHtml += `<td data-day="${day}" data-month="${m+1}"${cls}>${fmt(v)}</td>`;
        }
        bodyHtml += '</tr>';
      }

      bodyHtml += '<tr class="total-row"><td>Total rain (mm)</td>';
      for (let m=0; m<12; m++) bodyHtml += `<td>${fmt(monthTotals[m])}</td>`;
      bodyHtml += '</tr>';

      const cum = new Array(12).fill(0);
      for (let m=0; m<12; m++) cum[m] = (m===0 ? monthTotals[m] : cum[m-1] + monthTotals[m]);
      bodyHtml += '<tr class="cum-row"><td>Cumulative total (mm)</td>';
      for (let m=0; m<12; m++) bodyHtml += `<td>${fmt(cum[m])}</td>`;
      bodyHtml += '</tr>';

      bodyHtml += `<tr><td>Rain days (≥${RAIN_DAY_THRESHOLD_MM} mm)</td>`;
      for (let m=0; m<12; m++) bodyHtml += `<td>${monthRainDays[m] || ''}</td>`;
      bodyHtml += '</tr>';

      rainBody.innerHTML = bodyHtml;

      if (canEdit){
        const gaugeId = currentGauge.id;
        const year    = currentYear;
        rainBody.querySelectorAll('td.rain-cell-editable').forEach(td=>{
          td.addEventListener('click', async ()=>{
            const day   = parseInt(td.dataset.day,10);
            const month = parseInt(td.dataset.month,10);
            const existing = td.textContent.trim();
            const label = `${day}/${month}/${year}`;
            const input = window.prompt(`Rainfall for ${label} (mm). Leave blank to clear.`, existing);
            if (input === null) return;

            const trimmed = input.trim();
            try{
              if (!trimmed){
                await updateRainDoc(gaugeId, year, month, day, null);
              }else{
                const n = Number(trimmed);
                if (!Number.isFinite(n) || n < 0){ alert('Enter a non-negative number (mm).'); return; }
                await updateRainDoc(gaugeId, year, month, day, n);
              }
              await loadRainAndInsights();
            }catch(e){
              console.error(e);
              alert('Failed to save rainfall entry.');
            }
          });
        });
      }

      return { monthTotals, monthRainDays };
    }

    // ---------- Summary (climatology) ----------
    function updateSummary(year, stats){
      const monthTotalsThisYear = stats?.monthTotals || [];
      const rainDaysThisYear = stats?.monthRainDays || [];

      const thisYearTotal = monthTotalsThisYear.reduce((a,b)=>a+(b||0),0);
      const thisYearRainDays = rainDaysThisYear.reduce((a,b)=>a+(b||0),0);

      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const fmt1 = v => (v==null||!Number.isFinite(v)) ? '—' : Number(v).toFixed(1);
      const fmt0 = v => (v==null||!Number.isFinite(v)) ? '—' : String(Math.round(Number(v)));
      const fmtPct = v => (v==null||!Number.isFinite(v)) ? '—' : Number(v).toFixed(0) + '%';

      if (!summaryContent) return;

      if (!climatology || !climatology.longTerm){
        summaryContent.innerHTML = `<div class="summary-item">
          <strong>${year}</strong>
          <div class="muted">No climatology file found (consentes-house-rain.json).</div>
          <div>Total: ${fmt1(thisYearTotal)} mm</div>
          <div>Rain days (≥${RAIN_DAY_THRESHOLD_MM} mm): ${fmt0(thisYearRainDays)}</div>
          ${knownNoRecordYears.has(year) ? `<div class="muted">Marked: no record</div>` : ''}
        </div>`;
        return;
      }

      const lt = climatology.longTerm || {};

      // Support BOTH shapes:
      // Old: lt.annual (number), lt.monthly (array), lt.monthlyRainDays (array)
      // New: lt.annual.meanMm, lt.annual.meanRainDays, lt.monthly.meanMm, lt.monthly.meanRainDays
      const ltaAnnualMm =
        (typeof lt?.annual?.meanMm === 'number') ? lt.annual.meanMm :
        (typeof lt?.annual === 'number') ? lt.annual :
        null;

      const ltaAnnualRainDays =
        (typeof lt?.annual?.meanRainDays === 'number') ? lt.annual.meanRainDays :
        (typeof lt?.annualRainDays === 'number') ? lt.annualRainDays :
        null;

      const ltaMonthlyMm =
        Array.isArray(lt?.monthly?.meanMm) ? lt.monthly.meanMm :
        Array.isArray(lt?.monthly) ? lt.monthly :
        [];

      const ltaMonthlyRainDays =
        Array.isArray(lt?.monthly?.meanRainDays) ? lt.monthly.meanRainDays :
        Array.isArray(lt?.monthlyRainDays) ? lt.monthlyRainDays :
        [];

      const yearPct = (ltaAnnualMm && ltaAnnualMm > 0) ? (thisYearTotal / ltaAnnualMm * 100) : null;
      const baseFrom = lt?.basePeriod?.from;
      const baseTo = lt?.basePeriod?.to;
      const usedCount = Array.isArray(lt?.yearsUsed) ? lt.yearsUsed.length : (Array.isArray(lt?.years) ? lt.years.length : null);

      let html = '';

      html += `<div class="summary-item">
        <strong>${year} total</strong>
        <div>This year: ${fmt1(thisYearTotal)} mm</div>
        <div>Long-term annual: ${fmt1(ltaAnnualMm)} mm</div>
        <div>Year vs avg: ${fmtPct(yearPct)}</div>
        <div>This year rain days: ${fmt0(thisYearRainDays)}</div>
        <div>Avg rain days/year: ${fmt1(ltaAnnualRainDays)}</div>
        ${(baseFrom && baseTo) ? `<div class="muted small">Base period: ${baseFrom}–${baseTo}${usedCount ? ` (${usedCount} yrs)` : ''}</div>` : ''}
        ${knownNoRecordYears.has(year) ? `<div class="muted small">Marked: no record</div>` : ''}
      </div>`;

      for (let m=0; m<12; m++){
        const thisM = monthTotalsThisYear[m] || 0;
        const avgM  = (typeof ltaMonthlyMm[m] === 'number') ? ltaMonthlyMm[m] : null;
        const pct   = (avgM && avgM>0) ? (thisM / avgM * 100) : null;

        const thisRD = rainDaysThisYear[m] || 0;
        const avgRD  = (typeof ltaMonthlyRainDays[m] === 'number') ? ltaMonthlyRainDays[m] : null;

        let cls = '';
        if (pct != null){
          if (pct < 60) cls = 'summary-bad';
          else if (pct > 140) cls = 'summary-good';
        }

        html += `<div class="summary-item ${cls}">
          <strong>${months[m]}</strong>
          <div>This year: ${fmt1(thisM)} mm</div>
          <div>Average: ${fmt1(avgM)} mm</div>
          <div>Pct of avg: ${fmtPct(pct)}</div>
          <div>Rain days this year: ${fmt0(thisRD)}</div>
          <div>Avg rain days: ${fmt1(avgRD)}</div>
        </div>`;
      }

      summaryContent.innerHTML = html;
    }

    // ---------- Insights ----------
    const fmt1 = v => (v==null||!Number.isFinite(v)) ? '—' : Number(v).toFixed(1);
    const fmt0 = v => (v==null||!Number.isFinite(v)) ? '—' : String(Math.round(Number(v)));

    async function loadRainAndInsights(){
      await loadRain();
      await loadInsightsForGauge();
    }

    function computeQuickYearInsights(){
      const year = parseInt(yearSel.value,10);
      const grid = window.__sf_lastYearGrid;
      const stats = window.__sf_lastYearStats;
      if (!year || !grid || !stats) return null;

      const total = (stats.monthTotals || []).reduce((a,b)=>a+(b||0),0);
      const rainDays = (stats.monthRainDays || []).reduce((a,b)=>a+(b||0),0);

      let best = { mm: -1, iso: null };
      for (let m=1; m<=12; m++){
        for (let d=1; d<=31; d++){
          const v = grid[d-1]?.[m-1];
          if (v == null || !Number.isFinite(v)) continue;
          if (v > best.mm){
            best.mm = v;
            best.iso = `${year}-${pad2(m)}-${pad2(d)}`;
          }
        }
      }

      return { year, total, rainDays, wettestDayISO: best.iso, wettestDayMm: best.mm >= 0 ? best.mm : null };
    }

    // Recent: we assume missing doc means 0mm (normal, because you are not storing all-zero days)
    async function computeRecentInsights(gaugeId){
      const col = db.collection('gauges').doc(gaugeId).collection('daily');
      const idField = firebase.firestore.FieldPath.documentId();

      const snap = await col.orderBy(idField, 'desc').limit(1200).get();
      const mmByISO = new Map();
      snap.forEach(doc=>{
        const id = doc.id;
        if (/^\d{4}-\d{2}-\d{2}$/.test(id)){
          mmByISO.set(id, extractMm(doc.data() || {}));
        }
      });

      const today = todayISO();

      let lastRainISO = null;
      let lastRainMm = null;

      const maxLookbackDays = 800;

      // Find last rain day (>= threshold). Missing doc treated as 0mm.
      for (let i=0; i<=maxLookbackDays; i++){
        const iso = addDaysISO(today, -i);
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;
        if (mm >= RAIN_DAY_THRESHOLD_MM){
          lastRainISO = iso;
          lastRainMm = mm;
          break;
        }
      }

      const daysSinceLastRain = lastRainISO ? daysBetweenISO(lastRainISO, today) : null;

      // Current dry streak from today backwards (missing doc treated as 0mm)
      let currentDryStreakDays = 0;
      for (let i=0; i<=maxLookbackDays; i++){
        const iso = addDaysISO(today, -i);
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;
        if (mm < RAIN_DAY_THRESHOLD_MM) currentDryStreakDays++;
        else break;
      }

      // Rolling totals
      let sum7=0,sum30=0,sum90=0,rainDays30=0;
      for (let i=0; i<90; i++){
        const iso = addDaysISO(today, -i);
        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;
        if (i < 7) sum7 += mm;
        if (i < 30){
          sum30 += mm;
          if (mm >= RAIN_DAY_THRESHOLD_MM) rainDays30++;
        }
        sum90 += mm;
      }

      return { today, lastRainISO, lastRainMm, daysSinceLastRain, currentDryStreakDays, sum7, sum30, sum90, rainDays30 };
    }

    function getCachedHistoryStats(gaugeId){
      try{
        const raw = localStorage.getItem(`sf.rainHistoryStats.${gaugeId}`);
        if (!raw) return null;
        const p = JSON.parse(raw);
        return (p && typeof p === 'object') ? p : null;
      }catch(e){ return null; }
    }
    function setCachedHistoryStats(gaugeId, stats){
      try{
        localStorage.setItem(`sf.rainHistoryStats.${gaugeId}`, JSON.stringify(stats));
      }catch(e){}
    }

    // History: treat entire missing years as UNKNOWN so they do not create fake mega droughts.
    async function computeAndCacheHistoryStats(gaugeId){
      setStatus('Computing history stats…');
      insightsContent.innerHTML = `<div class="summary-item">Computing history stats (paged)…</div>`;

      const col = db.collection('gauges').doc(gaugeId).collection('daily');
      const idField = firebase.firestore.FieldPath.documentId();

      const mmByISO = new Map();
      const yearsPresent = new Set();

      let firstISO = null;
      let lastISO = null;

      let lastDoc = null;
      let pages = 0;

      while (true){
        let q = col.orderBy(idField, 'asc').limit(500);
        if (lastDoc) q = q.startAfter(lastDoc);

        const snap = await q.get();
        pages++;
        if (snap.empty) break;

        snap.forEach(doc=>{
          const id = doc.id;
          if (!/^\d{4}-\d{2}-\d{2}$/.test(id)) return;
          const mm = extractMm(doc.data() || {});
          mmByISO.set(id, mm);
          yearsPresent.add(id.slice(0,4));
          if (!firstISO) firstISO = id;
          lastISO = id;
        });

        lastDoc = snap.docs[snap.docs.length - 1];
        if (pages > 5000) throw new Error('Paging safety stop hit');
      }

      if (!firstISO || !lastISO){
        setCachedHistoryStats(gaugeId, null);
        setStatus('No history found', true);
        return null;
      }

      // Wettest day: only compare days that exist in data.
      let wettestDayISO = null;
      let wettestDayMm = -1;
      for (const [iso, mm] of mmByISO.entries()){
        if (mm > wettestDayMm){
          wettestDayMm = mm;
          wettestDayISO = iso;
        }
      }

      // Longest dry streak: assume missing doc = 0mm EXCEPT for years that have no docs at all.
      // If a year has no docs at all, treat that year as unknown and break streaks across it.
      let longestDryDays = 0;
      let longestDryStart = null;
      let longestDryEnd = null;

      let curDryDays = 0;
      let curDryStart = null;

      let iso = firstISO;
      while (true){
        const yStr = iso.slice(0,4);

        // Unknown year (like 1989) breaks the streak and is not counted.
        if (!yearsPresent.has(yStr)){
          if (curDryDays > longestDryDays){
            longestDryDays = curDryDays;
            longestDryStart = curDryStart;
            longestDryEnd = addDaysISO(iso, -1);
          }
          curDryDays = 0;
          curDryStart = null;

          if (iso === lastISO) break;
          iso = addDaysISO(iso, 1);
          continue;
        }

        const mm = mmByISO.has(iso) ? Number(mmByISO.get(iso) || 0) : 0;

        if (mm < RAIN_DAY_THRESHOLD_MM){
          if (curDryDays === 0) curDryStart = iso;
          curDryDays++;
        }else{
          if (curDryDays > longestDryDays){
            longestDryDays = curDryDays;
            longestDryStart = curDryStart;
            longestDryEnd = addDaysISO(iso, -1);
          }
          curDryDays = 0;
          curDryStart = null;
        }

        if (iso === lastISO) break;
        iso = addDaysISO(iso, 1);
      }

      if (curDryDays > longestDryDays){
        longestDryDays = curDryDays;
        longestDryStart = curDryStart;
        longestDryEnd = lastISO;
      }

      const out = {
        firstISO, lastISO,
        wettestDayISO,
        wettestDayMm: wettestDayMm >= 0 ? wettestDayMm : null,
        longestDryDays,
        longestDryStart,
        longestDryEnd,
        cachedAt: new Date().toISOString()
      };

      setCachedHistoryStats(gaugeId, out);
      setStatus('History stats updated');
      return out;
    }

    async function loadInsightsForGauge(){
      if (!currentGauge){
        insightsContent.innerHTML = `<div class="summary-item">Select a gauge.</div>`;
        return;
      }

      const quick = computeQuickYearInsights();
      const recent = await computeRecentInsights(currentGauge.id);
      const cached = getCachedHistoryStats(currentGauge.id);

      let html = '';

      html += `<div class="summary-item">
        <strong>Today</strong>
        <div>Date: ${recent.today}</div>
        <div>Rain day threshold: ≥${RAIN_DAY_THRESHOLD_MM} mm</div>
      </div>`;

      html += `<div class="summary-item">
        <strong>Since last rain</strong>
        <div>Days since last rain: ${recent.daysSinceLastRain != null ? fmt0(recent.daysSinceLastRain) : '—'}</div>
        <div>Last rain: ${recent.lastRainISO || '—'} (${recent.lastRainMm != null ? fmt1(recent.lastRainMm)+' mm' : '—'})</div>
        <div>Current dry streak: ${recent.currentDryStreakDays != null ? fmt0(recent.currentDryStreakDays)+' days' : '—'}</div>
      </div>`;

      html += `<div class="summary-item">
        <strong>Recent totals</strong>
        <div>Last 7 days: ${fmt1(recent.sum7)} mm</div>
        <div>Last 30 days: ${fmt1(recent.sum30)} mm</div>
        <div>Last 90 days: ${fmt1(recent.sum90)} mm</div>
        <div>Rain days (30d): ${fmt0(recent.rainDays30)}</div>
      </div>`;

      if (quick){
        html += `<div class="summary-item">
          <strong>${quick.year} snapshot</strong>
          <div>Total: ${fmt1(quick.total)} mm</div>
          <div>Rain days: ${fmt0(quick.rainDays)}</div>
          <div>Wettest day: ${quick.wettestDayISO || '—'} (${quick.wettestDayMm != null ? fmt1(quick.wettestDayMm)+' mm' : '—'})</div>
        </div>`;
      }

      if (cached){
        html += `<div class="summary-item">
          <strong>Record dry streak</strong>
          <div>Longest: ${fmt0(cached.longestDryDays)} days</div>
          <div>${cached.longestDryStart || '—'} to ${cached.longestDryEnd || '—'}</div>
          <div class="muted small">Cached: ${cached.cachedAt || '—'}</div>
        </div>`;

        html += `<div class="summary-item">
          <strong>Wettest day on record</strong>
          <div>${cached.wettestDayISO || '—'}</div>
          <div>${cached.wettestDayMm != null ? fmt1(cached.wettestDayMm)+' mm' : '—'}</div>
        </div>`;
      }else{
        html += `<div class="summary-item">
          <strong>All-time records</strong>
          <div class="muted">Not cached on this device yet.</div>
          <div>Click “Refresh history stats”.</div>
        </div>`;
      }

      html += `<div class="summary-item">
        <strong>Year labels</strong>
        <div>Years marked “(no record)” have zero daily docs in Firestore.</div>
        <div class="muted small">This is automatic.</div>
      </div>`;

      insightsContent.innerHTML = html;
    }

    refreshHistoryBtn.onclick = async ()=>{
      if (!currentGauge) return;
      try{
        await computeAndCacheHistoryStats(currentGauge.id);
        await loadInsightsForGauge();
      }catch(e){
        console.error(e);
        setStatus('Failed to compute history stats', true);
        alert('Failed to compute history stats. Check console.');
      }
    };

    // ---------- UI events ----------
    async function onGaugeChanged(){
      if (!gaugeSel.value) return;
      localStorage.setItem(ACTIVE_GAUGE_KEY, gaugeSel.value);
      currentGauge = gauges.find(g=>g.id === gaugeSel.value) || null;
      updateGaugeInfo();
      await rebuildYearsFromDataAndLoad();
    }

    reloadBtn.onclick = async ()=>{
      const y = parseInt(yearSel.value,10);
      if (y) localStorage.setItem(ACTIVE_YEAR_KEY, String(y));
      await loadRainAndInsights();
    };

    gaugeSel.onchange = onGaugeChanged;

    yearSel.onchange = async ()=>{
      const y = parseInt(yearSel.value,10);
      if (y) localStorage.setItem(ACTIVE_YEAR_KEY, String(y));
      await loadRainAndInsights();
    };

    printBtn.onclick = ()=> window.print();
  </script>
</body>
</html>
