<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SkyFarm ‚Äî Property Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg:#f6fbf8;
      --card:#ffffff;
      --ink:#0f172a;
      --muted:#64748b;
      --brand:#0B7A6E;
      --line:#e5e7eb;
      --warn:#9a3412;
    }
    *{box-sizing:border-box;}
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:var(--bg);
      margin:0;
      color:var(--ink);
    }

    /* Header */
    #sf-header{position:sticky;top:0;z-index:10;}
    #sf-header .bar{
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      background:#fff;
      border-bottom:1px solid var(--line);
      flex-wrap:wrap;
    }
    #sf-header .brand{
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--brand);
      font-weight:700;
      text-decoration:none;
    }
    #sf-header nav a{
      color:var(--brand);
      text-decoration:none;
      font-weight:600;
      margin-right:10px;
    }
    #sf-header nav a[aria-current="page"]{text-decoration:underline;}
    .spacer{flex:1;}
    .muted{color:var(--muted);font-size:.9rem;}
    .hidden{display:none;}

    .nav-db{position:relative;}
    .nav-db button{font-size:.9rem;}
    .db-menu{
      position:absolute;
      top:100%;
      left:0;
      background:#fff;
      border:1px solid var(--line);
      border-radius:10px;
      min-width:160px;
      padding:4px 0;
      box-shadow:0 10px 25px rgba(15,23,42,.12);
      z-index:20;
    }
    .db-menu a{
      display:block;
      padding:6px 12px;
      color:var(--ink);
      text-decoration:none;
      font-size:.9rem;
    }
    .db-menu a:hover{background:#f1f5f9;}

    .wrap{max-width:1200px;margin:0 auto;padding:16px;}
    h1{margin:12px 0;font-size:1.6rem;}
    .panel{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px;}
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:#ecfeff;
      font-size:.8rem;
      margin-right:4px;
    }

    label{font-size:.85rem;color:#475569;display:block;margin-bottom:4px;}
    select,input,button{
      padding:6px 10px;
      border-radius:10px;
      border:1px solid #cbd5e1;
      font:inherit;
      background:#fff;
    }
    button{cursor:pointer;}
    .btn{border-radius:10px;}
    .primary{background:var(--brand);color:#fff;border-color:var(--brand);}
    .danger{background:#ef4444;color:#fff;border-color:#ef4444;}

    /* Map layout */
    .map-layout{
      display:grid;
      grid-template-columns:1fr 360px;
      gap:16px;
      align-items:start;
    }

    /* This is the critical bit for mobile: force a real height */
    #map{
      width:100%;
      height:560px;       /* desktop / large screens */
      min-height:320px;
      background:#e5e7eb; /* light grey so you can tell if tiles fail */
      border-radius:12px;
    }

    .map-panel{
      padding:0;
    }

    /* Auth overlay */
    #authOverlay{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.06);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    #authCard{
      width:min(520px,92vw);
      background:#fff;
      border:1px solid var(--line);
      border-radius:16px;
      padding:20px;
    }
    #authCard h2{margin:0 0 10px;}

    /* --- Mobile: stack map & panel --- */
    @media (max-width:800px){
      .map-layout{
        display:flex;
        flex-direction:column;
      }
      #map{
        height:65vh;      /* 65% of viewport height */
        min-height:350px; /* never tiny */
      }
    }
  </style>
</head>
<body>

<!-- Header -->
<div id="sf-header">
  <div class="bar">
    <a class="brand" href="skyfarm-diary.html">üå± SkyFarm</a>
    <nav>
      <a href="skyfarm-diary.html">Diary</a>
      <a href="skyfarm-map.html" aria-current="page">Map</a>
      <a href="skyfarm-rain.html">Rain</a>
    </nav>
    <div class="nav-db">
      <button id="dbMenuBtn" class="btn small" type="button">Database ‚ñæ</button>
      <div id="dbMenu" class="db-menu hidden">
        <a href="skyfarm-livestock.html">Livestock</a>
        <a href="skyfarm-chemical.html">Chemicals</a>
        <a href="skyfarm-seeds.html">Seeds</a>
        <a href="skyfarm-fodder.html">Fodder</a>
        <a href="skyfarm-barcode.html">Barcode scanner</a>
        <a href="skyfarm-users.html">Users &amp; roles</a>
      </div>
    </div>
    <span class="spacer"></span>
    <span id="authWho" class="muted">Connecting‚Ä¶</span>
    <button id="signOutBtn" class="danger hidden">Sign out</button>
  </div>
</div>

<div class="wrap">
  <h1>Property Map</h1>
  <p id="status" class="muted">Loading paddock data‚Ä¶</p>

  <!-- Controls row -->
  <div class="panel" style="margin-bottom:12px;">
    <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
      <div>
        <label>Property</label>
        <select id="propertySel" style="min-width:200px;">
          <option value="ALL">(All properties)</option>
        </select>
      </div>
      <span class="muted" id="propertyHint">Zooms map to the selected property‚Äôs paddocks.</span>
    </div>
  </div>

  <div class="map-layout">
    <div class="panel map-panel">
      <div id="map"></div>
    </div>

    <aside class="panel">
      <h3 style="margin-top:0;">Paddock details</h3>
      <div id="paddockInfo" class="muted">
        Click a paddock to see livestock totals and recent diary entries (last 30 days).
      </div>
    </aside>
  </div>
</div>

<!-- Auth overlay -->
<div id="authOverlay">
  <div id="authCard">
    <h2>Sign in to SkyFarm</h2>
    <p class="muted" style="font-size:.85rem;">Email &amp; password only. Anonymous sign-in is disabled.</p>
    <div style="display:flex;flex-wrap:wrap;gap:10px;margin-bottom:8px;">
      <div style="flex:1;min-width:260px;">
        <label>Email</label>
        <input id="siEmail" type="email" placeholder="you@example.com" autocomplete="username">
      </div>
      <div style="flex:1;min-width:220px;">
        <label>Password</label>
        <input id="siPass" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password">
      </div>
    </div>
    <div style="display:flex;align-items:center;gap:8px;">
      <button id="signInBtn" class="primary btn">Sign in</button>
      <span id="authMsg" class="muted" style="font-size:.85rem;"></span>
      <span class="spacer"></span>
      <button id="closeOverlayBtn" class="btn" type="button">Close</button>
    </div>
  </div>
</div>

<script>
/* ---------- Firebase init ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBO9_0v1HdvVDuK3EFvaBGvQJIGvBwmW70",
  authDomain: "consentes-pastoral.firebaseapp.com",
  projectId: "consentes-pastoral",
  appId: "1:494858780013:web:d87497b370c82eeab06e64"
};
firebase.initializeApp(firebaseConfig);
const db   = firebase.firestore();
const auth = firebase.auth();

/* ---------- Header DB menu ---------- */
const dbMenuBtn = document.getElementById('dbMenuBtn');
const dbMenu    = document.getElementById('dbMenu');
if (dbMenuBtn && dbMenu){
  dbMenuBtn.onclick = (e)=>{ e.stopPropagation(); dbMenu.classList.toggle('hidden'); };
  document.addEventListener('click', e=>{
    if (!dbMenu.contains(e.target) && e.target !== dbMenuBtn) dbMenu.classList.add('hidden');
  });
}

/* ---------- Auth overlay ---------- */
const authOverlay  = document.getElementById('authOverlay');
const authWho      = document.getElementById('authWho');
const signOutBtn   = document.getElementById('signOutBtn');
const signInBtn    = document.getElementById('signInBtn');
const closeOverlay = document.getElementById('closeOverlayBtn');

function showOverlay(on){ authOverlay.style.display = on ? 'flex' : 'none'; }

signInBtn.onclick = async ()=>{
  const email = document.getElementById('siEmail').value.trim();
  const pass  = document.getElementById('siPass').value;
  const msgEl = document.getElementById('authMsg');
  msgEl.textContent = 'Signing in‚Ä¶';
  try{
    await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
    await auth.signInWithEmailAndPassword(email, pass);
    msgEl.textContent = 'Signed in.';
    showOverlay(false);
  }catch(e){
    msgEl.textContent = 'Sign-in failed: ' + (e?.message || e?.code || 'Unknown');
  }
};
closeOverlay.onclick = ()=> showOverlay(false);
signOutBtn.onclick   = async ()=>{ try{ await auth.signOut(); location.reload(); }catch(e){} };

/* ---------- UI helpers ---------- */
const statusEl      = document.getElementById('status');
const paddockInfoEl = document.getElementById('paddockInfo');
const propertySel   = document.getElementById('propertySel');
function setStatus(t){ if (statusEl) statusEl.textContent = t; }
function esc(s){
  return String(s ?? '').replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c]));
}

/* ---------- Map ---------- */
const map = L.map('map').setView([-20.0, 142.5], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom:19,
  attribution:'&copy; OpenStreetMap contributors'
}).addTo(map);

/* Force Leaflet to recalc size in a few situations (iOS is fussy) */
function ensureMapSize(){
  try{ map.invalidateSize(); }catch(e){}
}
window.addEventListener('resize', ensureMapSize);
window.addEventListener('orientationchange', ensureMapSize);
window.addEventListener('load', ()=> setTimeout(ensureMapSize, 300));
document.addEventListener('visibilitychange', ()=>{
  if (!document.hidden) setTimeout(ensureMapSize, 300);
});

/* ---------- Constants & sources ---------- */
const KNOWN_PROPERTIES = {
  "Consentes": "s7PlDM9wrEpxuJ6DGIab",
  "Mt Myrtle": "TRuxtRBx2zJlwZnRGYKJ",
  "Gerawin":   "P0dQ0H2FWHeqqxejflZs"
};
const CLOUD_URLS = [
  "https://storage.googleapis.com/consentes-maps/consentes_station.json",
  "https://storage.googleapis.com/consentes-maps/mt_myrtle.json"
];
const LOCAL_FALLBACKS = [
  "maps/consentes_station.json",
  "maps/mt_myrtle.json"
];
const ACTIVE_PROPERTY_KEY = 'sf.map.activePropertyId';

const propertyMeta   = new Map();
const paddockIndex   = new Map();
const livestockIndex = new Map();
const diaryCache     = new Map();

let allBounds      = null;
let firestoreReady = false;

/* ---------- Firestore-backed indexes ---------- */
async function loadProperties(){
  propertyMeta.clear();
  const snap = await db.collection('properties').get();
  snap.forEach(doc=>{
    const d = doc.data() || {};
    const name = d.name || '(Property)';
    propertyMeta.set(doc.id, { name, bounds:null });
  });
  for (const [name,id] of Object.entries(KNOWN_PROPERTIES)){
    if (!propertyMeta.has(id)) propertyMeta.set(id, { name, bounds:null });
  }
}

async function loadPaddocksIndex(){
  paddockIndex.clear();
  const snap = await db.collection('paddocks').get();
  snap.forEach(doc=>{
    const d = doc.data() || {};
    const name = (d.name || '').trim();
    const pid  = d.propertyId || null;
    if (!name || !pid) return;
    const pm = propertyMeta.get(pid);
    paddockIndex.set(name, {
      propertyId: pid,
      propertyName: pm ? pm.name : '(Property)'
    });
  });
}

async function loadLivestockIndex(){
  livestockIndex.clear();
  const snap = await db.collection('livestock').get();
  snap.forEach(doc=>{
    const d = doc.data() || {};
    const propId  = d.propertyId;
    const paddock = (d.location || '').trim();
    const count   = Number(d.count || 0);
    if (!propId || !paddock || !count) return;

    const key = propId + '|' + paddock;
    let rec = livestockIndex.get(key);
    if (!rec){
      rec = { total:0, byClass:{} };
      livestockIndex.set(key, rec);
    }
    rec.total += count;
    const cls = (d.class || d.species || 'Stock').trim() || 'Stock';
    rec.byClass[cls] = (rec.byClass[cls] || 0) + count;
  });
}

/* ---------- Diary helpers ---------- */
async function getRecentDiary(propertyId, paddockName){
  const cacheKey = propertyId + '|' + paddockName;
  if (diaryCache.has(cacheKey)) return diaryCache.get(cacheKey);

  const today = new Date();
  const from  = new Date(today.getTime() - 30*24*60*60*1000);
  const fromISO = from.toISOString().slice(0,10);

  const out = [];
  const snap = await db.collection('diaryEntries')
    .where('propertyId', '==', propertyId)
    .orderBy('date', 'desc')
    .limit(100)
    .get();

  snap.forEach(doc=>{
    const d = doc.data() || {};
    if ((d.paddock || '').trim() !== paddockName) return;
    const dateStr = d.date || '';
    if (dateStr && dateStr < fromISO) return;
    out.push({
      date: dateStr,
      activity: d.activity || '',
      notes: d.notes || ''
    });
  });

  diaryCache.set(cacheKey, out);
  return out;
}

/* ---------- Render paddock info ---------- */
function renderPaddockInfo(propertyName, paddockName, stockRec, diaryList){
  let html = '';
  html += `<div><strong>Paddock:</strong> ${esc(paddockName)}</div>`;
  html += `<div><strong>Property:</strong> ${esc(propertyName)}</div>`;

  if (stockRec){
    html += `<div style="margin-top:6px;"><strong>Livestock in paddock:</strong> ${stockRec.total}</div>`;
    const classes = Object.keys(stockRec.byClass);
    if (classes.length){
      html += '<div style="margin-top:4px;font-size:.9rem;">';
      classes.sort().forEach(c=>{
        html += `<span class="pill">${esc(c)}: ${stockRec.byClass[c]}</span>`;
      });
      html += '</div>';
    }
  } else {
    html += `<div style="margin-top:6px;">No livestock records for this paddock.</div>`;
  }

  if (diaryList && diaryList.length){
    html += `<div style="margin-top:10px;"><strong>Recent diary entries (last 30 days)</strong></div>`;
    html += '<ul style="margin:4px 0 0 18px;padding:0;font-size:.9rem;">';
    diaryList.forEach(e=>{
      const label = [e.date, e.activity].filter(Boolean).join(' ‚Äî ');
      const notes = e.notes ? `: ${esc(e.notes)}` : '';
      html += `<li>${esc(label)}${notes}</li>`;
    });
    html += '</ul>';
  } else {
    html += `<div style="margin-top:10px;">No diary entries for this paddock in the last 30 days.</div>`;
  }

  paddockInfoEl.innerHTML = html;
}

/* ---------- Paddock click ---------- */
async function handlePaddockClick(mapIndex, feature){
  const paddockName = (feature.properties && feature.properties.title)
    ? String(feature.properties.title).trim()
    : 'Paddock';

  let pid = null;
  let propertyName = '';

  const idx = paddockIndex.get(paddockName);
  if (idx){
    pid = idx.propertyId;
    propertyName = idx.propertyName;
  }else{
    if (mapIndex === 0){
      pid = KNOWN_PROPERTIES["Consentes"];
      propertyName = "Consentes / Gerawin";
    }else if (mapIndex === 1){
      pid = KNOWN_PROPERTIES["Mt Myrtle"];
      propertyName = "Mt Myrtle";
    }
  }

  if (!pid){
    paddockInfoEl.innerHTML = `<span class="muted">No property match for paddock ‚Äú${esc(paddockName)}‚Äù.</span>`;
    return;
  }

  if (!propertyName){
    const meta = propertyMeta.get(pid);
    propertyName = meta ? meta.name : '(Property)';
  }

  if (!firestoreReady){
    paddockInfoEl.innerHTML = '<span class="muted">Still connecting to Firebase‚Ä¶ try again in a moment.</span>';
    return;
  }

  const key      = pid + '|' + paddockName;
  const stockRec = livestockIndex.get(key);

  paddockInfoEl.innerHTML = '<span class="muted">Loading diary entries‚Ä¶</span>';

  let diaryList = [];
  try{
    diaryList = await getRecentDiary(pid, paddockName);
  }catch(e){
    diaryList = [];
  }

  renderPaddockInfo(propertyName, paddockName, stockRec, diaryList);
}

/* ---------- GeoJSON fetch with fallback ---------- */
async function fetchWithFallback(primaryUrl, fallbackUrl){
  try{
    const r = await fetch(primaryUrl, {cache:'no-store'});
    if (!r.ok) throw new Error('HTTP ' + r.status);
    return await r.json();
  }catch(e){
    const r2 = await fetch(fallbackUrl, {cache:'no-store'});
    if (!r2.ok) throw new Error('Fallback HTTP ' + r2.status);
    return await r2.json();
  }
}

/* ---------- Property dropdown & zoom ---------- */
function rebuildPropertyDropdown(){
  const entries = [];
  propertyMeta.forEach((meta,id)=>{
    if (meta.bounds) entries.push({id,name:meta.name});
  });
  entries.sort((a,b)=> a.name.localeCompare(b.name));

  const saved = localStorage.getItem(ACTIVE_PROPERTY_KEY) || 'ALL';
  propertySel.innerHTML = '<option value="ALL">(All properties)</option>';
  entries.forEach(p=>{
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.name;
    propertySel.appendChild(opt);
  });

  if (saved !== 'ALL' && propertyMeta.has(saved) && propertyMeta.get(saved).bounds){
    propertySel.value = saved;
    zoomToProperty(saved);
  }else{
    propertySel.value = 'ALL';
    if (allBounds) map.fitBounds(allBounds, {padding:[20,20]});
  }

  propertySel.onchange = ()=>{
    const val = propertySel.value;
    localStorage.setItem(ACTIVE_PROPERTY_KEY, val);
    zoomToProperty(val);
  };
}

function zoomToProperty(propertyId){
  if (propertyId === 'ALL'){
    if (allBounds) map.fitBounds(allBounds, {padding:[20,20]});
    return;
  }
  const meta = propertyMeta.get(propertyId);
  if (meta && meta.bounds){
    map.fitBounds(meta.bounds, {padding:[20,20]});
  }
}

/* ---------- Auth + Firestore bootstrap ---------- */
auth.onAuthStateChanged(async user=>{
  if (user){
    authWho.textContent = user.email ? `Signed in as ${user.email}` : 'Signed in';
    signOutBtn.classList.remove('hidden');
    showOverlay(false);
    try{ await db.enablePersistence({synchronizeTabs:true}); }catch(e){}
    try{
      setStatus('Loading properties & paddocks‚Ä¶');
      await loadProperties();
      await loadPaddocksIndex();
      setStatus('Loading livestock‚Ä¶');
      await loadLivestockIndex();
      firestoreReady = true;
      setStatus('Loading map‚Ä¶');
      await loadMapLayers();
      setStatus('Map ready. Click a paddock to see livestock and diary.');
      ensureMapSize();
    }catch(e){
      firestoreReady = false;
      setStatus('Error loading data for map.');
      console.error(e);
    }
  } else {
    authWho.textContent = 'Not signed in';
    signOutBtn.classList.add('hidden');
    firestoreReady = false;
    showOverlay(true);
    setStatus('Please sign in to see livestock & diary on paddocks.');
  }
});

/* ---------- Map layers ---------- */
function featureStyle(feature){
  const t = feature?.geometry?.type;
  if (t === 'Polygon' || t === 'MultiPolygon'){
    return { color:'#00897B', weight:2, fillOpacity:0.25 };
  }
  return { color:'#64748b', weight:1, fillOpacity:0 };
}

async function loadMapLayers(){
  allBounds = null;

  for (let i=0;i<CLOUD_URLS.length;i++){
    try{
      const data = await fetchWithFallback(CLOUD_URLS[i], LOCAL_FALLBACKS[i]);
      if (!data || !(data.type === 'FeatureCollection' || data.type === 'Feature')) continue;

      const layer = L.geoJSON(data, {
        style: featureStyle,
        onEachFeature: (feature, lyr)=>{
          const t = feature?.geometry?.type;
          const isPaddock = t === 'Polygon' || t === 'MultiPolygon';

          if (isPaddock){
            const title = (feature.properties && feature.properties.title) ? String(feature.properties.title).trim() : '';
            let pid = null;

            const idx = paddockIndex.get(title);
            if (idx){
              pid = idx.propertyId;
            }else{
              if (i === 1){
                pid = KNOWN_PROPERTIES["Mt Myrtle"];
              }
            }

            const b = (typeof lyr.getBounds === 'function') ? lyr.getBounds() : null;
            if (b && b.isValid && b.isValid()){
              if (!allBounds) allBounds = b; else allBounds.extend(b);
              if (pid && propertyMeta.has(pid)){
                const meta = propertyMeta.get(pid);
                if (!meta.bounds) meta.bounds = b; else meta.bounds.extend(b);
              }
            }

            lyr.on('click', ()=> handlePaddockClick(i, feature));
          } else if (feature.properties && feature.properties.title){
            lyr.bindTooltip(String(feature.properties.title), {direction:'top'});
          }
        }
      }).addTo(map);

      try{
        const lb = layer.getBounds();
        if (lb && lb.isValid && lb.isValid()){
          if (!allBounds) allBounds = lb; else allBounds.extend(lb);
        }
      }catch(_){}
    }catch(e){
      console.error('Failed to load map source', i, e);
    }
  }

  rebuildPropertyDropdown();
  if (!allBounds){
    setStatus('No features drawn');
  }else{
    map.fitBounds(allBounds, {padding:[20,20]});
  }
  ensureMapSize();
}
</script>
</body>
</html>
